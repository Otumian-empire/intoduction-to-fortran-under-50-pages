1 - Basics

! - starts a comment

Every code must have a program name and end program name, as in 

program helloworld
! code here

end helloworld

implicit none - checks if all variables are declared

variable declaration
type :: var

as in , real :: x, y and integer :: age, numberOfDays

print *, objects
read *, objects

we can do,
program simplecode
! this program demonstrate what we have seen so far

integer :: a, b, c

print *, "Enter a:"
read *, a

print *, "Enter a:"
read *, a

c = a+b

print *, c

end program simplecode

It is considered that every file must have one program

character data type.
this is most similar to c
in c, char name[10];
in fortran, character :: name*10


2 - Making Decisions

var = val, is a simple assigment statement

operators: +, -, *, /, **, (), mod

intrinsic functions are builtin functions such as sin, cos, exp, tan,
 atan, log, modetc

==, checks for equality, like C

if statement follows the patterns
if (condition) then code end if

program sampleIf
integer :: age
read *, age
if (age == 10) then
    print*, 'you are ten'
end if
end program sampleIf

A good program:
- Uses comments appropriately to explain what is happening.
- Uses indentation to make the program easier to read.
- Uses meaningful variable names.
- Uses sensible prompts to let the user know what is going on.
- Uses implicit none at the start of every program.
- Is efficient!

if then, else if then and else and end if

program sampleIfElse
implicit none
integer :: num
print*, 'enter num'
read *, num

if (num == 10) then
    num = num - 2
else if (num == 9) then
    num = num - 3
else
    num = 0
end if
print *, num

end program sampleIf

relation operators: ==, /=, <, >, <=, >=
logical operators: .and., .or.

stop - literally stops the program

if (condition) stop

there is a difference in a real zero and an integer zero,
as such you should find the absolute value of the real of interest,
check if its less than some arbituary number, say, 0.000001


3 - Loops

integer division does not result in a real result

do-loop allows reexecution of codes, just like a for-loop in c

do-loop is of the form
do var = begin, end, step
    code
end do

The do loop is start and end inclusive unlike c where by, 0 to 20 is 0 to 19

Nested loops
do var_i=a,b,c
    do var_j=d,e,f
        ! code
    end do
end do


4 Using Files and Extending Precision

use open to open a file. Using takes two args, a positional arg and kwarg.
these are unit/input device, an int value - something the a device/object and file name
as file=fileName

read *, someVar, read data into someVar but has to be modified to read from file.
read(device, *) someVars , there is no comma after the closing bracket

program readIntFromFile
    ! create a file, data.txt and enter a number into it, save it
    
    implicit none
    
    integer :: i
    open(1, file='data.txt')
    read(1, *) i
    
    print*, i
    
end program readCharFromFile

open links the file to read with an input device numbered 1
write behave like read, so just in the above code, chnage read to write to write to file

program writeToFile
    ! create a file, data.txt and enter a number into it, save it
    
    implicit none
    
    integer :: i
    open(1, file='data.txt')
    read(1, *) i
    
    print*, i
    
end program writeToFile

By default the precisions of integer and real is 6dp but can be extended
This is almost the same concept around typdef - creating a new data type
type, parameter :: typeKind=selected_real_kind(p=val)

To make a type of the new data type, 
type (kind=newDataType) :: var_name

One other way is to append the new type as val_newDataType as in 1.34_newDataType


5 Arrays and Formatted I/O

An array is a list that we can access through a subscript
we just size of an array when we declare it.
As in, real, dimension(100) :: arr, creates an array if size 100

subscripting, arr(index), where the array index starts from 1, unlike c, which is 0
print *, array, prints the content of the array

program arrays
    implicit none

    ! declare an array of size, 10
    integer, dimension(10) :: intArray
    
    ! populate the array, using a loop
    integer :: i
    do i = 1, 10
        intArray(i) = i
    end do
    
    print *, intArray
    
end program

To make the code above maintainable we can create a simple variable to hold the size of the 
array. This a parameter.

integer, parameter :: arraySize = 10
integer, dimension(arraySize) :: intArray

arraySize could even be passed in to the loop

Arrays can be created run time as wells, where by the size of the array is create when the
 user passes the size
 
make the arrayVar allocatable, here the dimension is set to, dimension(:)
allocate the size of the array when taken from the user
deallocate the array

program runTimeArray
    implicit none
    
    ! declare the array, allocatable with  dimension(:)
    integer, allocatable, dimension(:) :: arr
    
    integer :: arraySize
    
    ! loop var
    integer :: i
    
    ! read/determin array size
    print *, 'enter array size'
    read *, arraySize
    
    ! allocate memory of arraySize to array
    allocate(arr(arraySize))
    
    ! populate the array
   
    do i = 1, arraySize
        arr(i) = i ** 2
    end do
    
    ! print arr
    print*, arr
    
    ! release memory
    deallocate(arr)
    
end program

operations can easily be done on every arrays element by using simple arithmetic operators.











