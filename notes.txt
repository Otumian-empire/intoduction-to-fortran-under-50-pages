1 - Basics

! - starts a comment

Every code must have a program name and end program name, as in 

program helloworld
! code here

end helloworld

implicit none - checks if all variables are declared

variable declaration
type :: var

as in , real :: x, y and integer :: age, numberOfDays

print *, objects
read *, objects

we can do,
program simplecode
! this program demonstrate what we have seen so far

integer :: a, b, c

print *, "Enter a:"
read *, a

print *, "Enter a:"
read *, a

c = a+b

print *, c

end program simplecode

It is considered that every file must have one program

character data type.
this is most similar to c
in c, char name[10];
in fortran, character :: name*10


2 - Making Decisions

var = val, is a simple assigment statement

operators: +, -, *, /, **, (), mod

intrinsic functions are builtin functions such as sin, cos, exp, tan,
 atan, log, modetc

==, checks for equality, like C

if statement follows the patterns
if (condition) then code end if

program sampleIf
integer :: age
read *, age
if (age == 10) then
    print*, 'you are ten'
end if
end program sampleIf

A good program:
- Uses comments appropriately to explain what is happening.
- Uses indentation to make the program easier to read.
- Uses meaningful variable names.
- Uses sensible prompts to let the user know what is going on.
- Uses implicit none at the start of every program.
- Is efficient!

if then, else if then and else and end if

program sampleIfElse
implicit none
integer :: num
print*, 'enter num'
read *, num

if (num == 10) then
    num = num - 2
else if (num == 9) then
    num = num - 3
else
    num = 0
end if
print *, num

end program sampleIf

relation operators: ==, /=, <, >, <=, >=
logical operators: .and., .or.

stop - literally stops the program

if (condition) stop

there is a difference in a real zero and an integer zero,
as such you should find the absolute value of the real of interest,
check if its less than some arbituary number, say, 0.000001


3 - Loops

integer division does not result in a real result

do-loop allows reexecution of codes, just like a for-loop in c

do-loop is of the form
do var = begin, end, step
    code
end do

The do loop is start and end inclusive unlike c where by, 0 to 20 is 0 to 19

Nested loops
do var_i=a,b,c
    do var_j=d,e,f
        ! code
    end do
end do


4 Using Files and Extending Precision

use open to open a file. Using takes two args, a positional arg and kwarg.
these are unit/input device, an int value - something the a device/object and file name
as file=fileName

read *, someVar, read data into someVar but has to be modified to read from file.
read(device, *) someVars , there is no comma after the closing bracket

program readIntFromFile
    ! create a file, data.txt and enter a number into it, save it
    
    implicit none
    
    integer :: i
    open(1, file='data.txt')
    read(1, *) i
    
    print*, i
    
end program readCharFromFile

open links the file to read with an input device numbered 1
write behave like read, so just in the above code, chnage read to write to write to file

program writeToFile
    ! create a file, data.txt and enter a number into it, save it
    
    implicit none
    
    integer :: i
    open(1, file='data.txt')
    read(1, *) i
    
    print*, i
    
end program writeToFile

By default the precisions of integer and real is 6dp but can be extended
This is almost the same concept around typdef - creating a new data type
type, parameter :: typeKind=selected_real_kind(p=val)

To make a type of the new data type, 
type (kind=newDataType) :: var_name

One other way is to append the new type as val_newDataType as in 1.34_newDataType






